"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.version = exports.input = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const os_1 = tslib_1.__importDefault(require("os"));
const util_1 = tslib_1.__importDefault(require("util"));
const child_process_1 = require("child_process");
const glob_1 = tslib_1.__importDefault(require("glob"));
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const DEFAULT_BIN = 'pdftocairo';
/**
 * @see http://manpages.ubuntu.com/manpages/bionic/man1/pdftocairo.1.html
 */
const ERROR_MESSAGES = {
    0: 'No error.',
    1: 'Error opening a PDF file.',
    2: 'Error opening an output file.',
    3: 'Error related to PDF permissions.',
    4: 'Error related to ICC profile.',
    99: 'Other error.',
};
const getOptionArgs = (options) => {
    const args = [];
    args.push(`-${options.format}`);
    if (options.range) {
        if (typeof options.range.f === 'number')
            args.push(`-f ${options.range.f}`);
        if (typeof options.range.l === 'number')
            args.push(`-l ${options.range.l}`);
    }
    if (options.filter) {
        const arg = options.filter === 'odd' ? '-o' : '-e';
        args.push(arg);
    }
    if (options.singlefile)
        args.push('-singlefile');
    if (options.resolution) {
        if (typeof options.resolution === 'number') {
            args.push(`-r ${options.resolution}`);
        }
        else {
            if (typeof options.resolution.x === 'number') {
                args.push(`-rx ${options.resolution.x}`);
            }
            if (typeof options.resolution.y === 'number') {
                args.push(`-ry ${options.resolution.y}`);
            }
        }
    }
    if (options.scale) {
        if (typeof options.scale === 'number') {
            args.push(`-scale-to ${options.scale}`);
        }
        else {
            if (typeof options.scale.x === 'number') {
                args.push(`-scale-to-x ${options.scale.x}`);
            }
            if (typeof options.scale.y === 'number') {
                args.push(`-scale-to-y ${options.scale.y}`);
            }
        }
    }
    if (options.paper) {
        if (typeof options.paper === 'string') {
            args.push(`-paper ${options.paper}`);
        }
        else {
            if (typeof options.paper.w === 'number') {
                args.push(`-paperw ${options.paper.w}`);
            }
            if (typeof options.paper.h === 'number') {
                args.push(`-paperh ${options.paper.h}`);
            }
        }
    }
    if (options.crop) {
        if (options.crop.x)
            args.push(`-x ${options.crop.x}`);
        if (options.crop.y)
            args.push(`-y ${options.crop.y}`);
        if (options.crop.H)
            args.push(`-H ${options.crop.H}`);
        if (options.crop.W)
            args.push(`-W ${options.crop.W}`);
        if (options.crop.sz)
            args.push(`-sz ${options.crop.sz}`);
    }
    if (options.cropbox)
        args.push('-cropbox');
    if (options.mono)
        args.push('-mono');
    if (options.gray)
        args.push('-gray');
    if (options.antialias)
        args.push(`-antialias ${options.antialias}`);
    if (options.level2)
        args.push('-level2');
    if (options.level3)
        args.push('-level3');
    if (options.transparent)
        args.push('-transp');
    if (options.originPageSizes)
        args.push('-origpagesizes');
    if (options.icc)
        args.push(`-icc ${options.icc}`);
    if (options.jpegopt)
        args.push(`-jpegopt ${options.jpegopt}`);
    if (options.nocrop)
        args.push('-nocrop');
    if (options.expand)
        args.push('-expand');
    if (options.noshrink)
        args.push('-noshrink');
    if (options.nocenter)
        args.push('-nocenter');
    if (options.duplex)
        args.push('-duplex');
    if (options.ownerPassword)
        args.push(`-opw ${options.ownerPassword}`);
    if (options.userPassword)
        args.push(`-upw ${options.userPassword}`);
    args.push('-q');
    return args;
};
const findFiles = (patten) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        glob_1.default(patten, (err, files) => (err ? reject(err) : resolve(files)));
    });
});
const withTempDir = (fn) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const dir = yield fs_1.default.promises.mkdtemp((yield fs_1.default.promises.realpath(os_1.default.tmpdir())) + path_1.default.sep);
    try {
        return yield fn(dir);
    }
    finally {
        yield util_1.default.promisify(rimraf_1.default)(dir);
    }
});
class PDFToCairo {
    constructor(file, options) {
        this.args = [];
        this.input = file;
        this.bin = options.bin || process.env.PDFTOCAIRO_PATH || DEFAULT_BIN;
        this.args.push(...getOptionArgs(options));
    }
    output(outputFile) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // '-' means reading PDF file from stdin
            const inputPath = typeof this.input === 'string' ? this.input : '-';
            const generateFiles = (outputPath) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.args.push(inputPath, outputPath);
                const child = child_process_1.spawn(this.bin, this.args, { shell: true });
                if (typeof this.input !== 'string') {
                    child.stdin.setDefaultEncoding('utf-8');
                    child.stdin.write(this.input);
                    child.stdin.end();
                }
                return new Promise((resolve, reject) => {
                    child.on('close', (code) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        if (code !== 0) {
                            reject(ERROR_MESSAGES[code]);
                            return;
                        }
                        if (typeof outputFile === 'string') {
                            resolve(null);
                        }
                        else {
                            const files = yield findFiles(`${outputPath}*`);
                            const buffers = yield Promise.all(files.sort().map((file) => fs_1.default.promises.readFile(file)));
                            resolve(buffers);
                        }
                    }));
                });
            });
            if (outputFile) {
                return generateFiles(outputFile);
            }
            return withTempDir((tmp) => generateFiles(path_1.default.join(tmp, 'result')));
        });
    }
    version() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield util_1.default.promisify(child_process_1.exec)(`${this.bin} -v`)).stderr;
        });
    }
}
const input = (file, options) => new PDFToCairo(file, options);
exports.input = input;
const version = (options) => new PDFToCairo('', options !== null && options !== void 0 ? options : { format: 'png' }).version();
exports.version = version;
